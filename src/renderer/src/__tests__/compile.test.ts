import { describe, it, expect, vi, beforeEach } from 'vitest'
import { Workspace } from '../views/workspace'
import type { InstallerState } from '../models/installer-state'
import type { ArduinoCliService } from '../services/arduino-cli.service'
import type { FileService } from '../services/file.service'

// ── Factory ───────────────────────────────────────────────────────────────────

function makeWorkspace(overrides: {
    state?: Partial<InstallerState>
    cli?: Partial<ArduinoCliService>
    files?: Partial<FileService>
} = {}): Workspace {
    const ws = Object.create(Workspace.prototype) as Workspace

    const state = {
        selectedDevice: null,
        repoPath: null,
        configFiles: [],
        savedConfigurations: [],
        activeConfigId: null,
        selectedProduct: null,
        selectedVersion: null,
        ...overrides.state,
    } as InstallerState

    const files = {
        writeFile: vi.fn().mockResolvedValue(undefined),
        readFile: vi.fn().mockResolvedValue(''),
        exists: vi.fn().mockResolvedValue(true),
        ...overrides.files,
    } as unknown as FileService

    const cli = {
        compile: vi.fn().mockResolvedValue({ success: true, output: '' }),
        upload: vi.fn(),
        ...overrides.cli,
    } as unknown as ArduinoCliService

    Object.assign(ws, {
        state,
        cli,
        files,
        router: { load: vi.fn() },
        dialogService: {},
        preferences: { get: vi.fn(), set: vi.fn() },
        isCompiling: false,
        compileLog: '',
        compileError: null,
        compileSuccess: null,
        progressPercent: 0,
        showDeviceMenu: false,
        savedConfigs: [],
        activeFileIndex: 0,
    })

    return ws
}

const REPO = '/home/user/ex-installer/repos/CommandStation-EX'

const megaDevice = {
    name: 'Arduino Mega 2560',
    port: '/dev/ttyACM0',
    fqbn: 'arduino:avr:mega',
    protocol: 'serial' as const,
    serialNumber: undefined,
}

const espDevice = {
    name: 'ESP32-S3',
    port: '/dev/ttyUSB0',
    fqbn: 'esp32:esp32:esp32s3',
    protocol: 'serial' as const,
    serialNumber: undefined,
}

const configFiles = [
    { name: 'config.h', content: '#define IP_PORT 2560\n#define SCROLLMODE 1\n#define MOTOR_SHIELD_TYPE STANDARD_MOTOR_SHIELD\n' },
    { name: 'myAutomation.h', content: '// myAutomation.h - Generated by EX-Installer\n' },
]

// ── Guard conditions ──────────────────────────────────────────────────────────

describe('Workspace.compile — guard conditions', () => {
    it('returns immediately when selectedDevice is null', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: null, repoPath: REPO } })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
        expect(ws.compileLog).toBe('')
        expect((ws as any).cli.compile).not.toHaveBeenCalled()
    })

    it('returns immediately when repoPath is null', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: null } })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
        expect(ws.compileLog).toBe('')
        expect((ws as any).cli.compile).not.toHaveBeenCalled()
    })

    it('returns immediately when both device and repoPath are null', async () => {
        const ws = makeWorkspace()
        await ws.compile()
        expect((ws as any).cli.compile).not.toHaveBeenCalled()
    })
})

// ── FQBN validation ───────────────────────────────────────────────────────────

describe('Workspace.compile — FQBN validation', () => {
    it('sets compileSuccess=false when FQBN is empty string', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: { ...megaDevice, fqbn: '' }, repoPath: REPO } })
        await ws.compile()
        expect(ws.compileSuccess).toBe(false)
    })

    it('includes board name in error when FQBN is missing', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: { ...megaDevice, name: 'CH340 Clone', fqbn: '' }, repoPath: REPO } })
        await ws.compile()
        expect(ws.compileError).toContain('CH340 Clone')
    })

    it('error message mentions FQBN', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: { ...megaDevice, fqbn: '' }, repoPath: REPO } })
        await ws.compile()
        expect(ws.compileError).toMatch(/fqbn/i)
    })

    it('does not call cli.compile when FQBN is missing', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: { ...megaDevice, fqbn: '' }, repoPath: REPO } })
        await ws.compile()
        expect((ws as any).cli.compile).not.toHaveBeenCalled()
    })

    it('isCompiling is false after FQBN error', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: { ...megaDevice, fqbn: '' }, repoPath: REPO } })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
    })
})

// ── State reset on each call ──────────────────────────────────────────────────

describe('Workspace.compile — state reset on each call', () => {
    it('clears compileLog from a previous run', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO } })
        ws.compileLog = 'stale output from last run'
        await ws.compile()
        expect(ws.compileLog).not.toContain('stale output from last run')
    })

    it('clears compileError from a previous run', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO } })
        ws.compileError = 'previous error'
        await ws.compile()
        expect(ws.compileError).toBeNull()
    })

    it('resets compileSuccess to null before running', async () => {
        // Verify that a prior true doesn't bleed through on a new failing run
        const compileMock = vi.fn().mockResolvedValue({ success: false, output: '', error: 'new error' })
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO },
            cli: { compile: compileMock },
        })
        ws.compileSuccess = true
        await ws.compile()
        expect(ws.compileSuccess).toBe(false)
    })

    it('resets progressPercent to 10 at the start', async () => {
        let capturedProgress = -1
        const compileMock = vi.fn().mockImplementation(async () => {
            capturedProgress = (ws as any).progressPercent
            return { success: true, output: '' }
        })
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] }, cli: { compile: compileMock } })
        ws.progressPercent = 99
        await ws.compile()
        // By the time compile() is called, we're at 40 (after save=20, fqbn check, then log+set40)
        expect(capturedProgress).toBe(40)
    })
})

// ── File saving ───────────────────────────────────────────────────────────────

describe('Workspace.compile — file saving before compile', () => {
    it('writes config.h to the correct path', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles } })
        await ws.compile()
        const writeFile = (ws as any).files.writeFile as ReturnType<typeof vi.fn>
        expect(writeFile).toHaveBeenCalledWith(`${REPO}/config.h`, configFiles[0].content)
    })

    it('writes myAutomation.h to the correct path', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles } })
        await ws.compile()
        const writeFile = (ws as any).files.writeFile as ReturnType<typeof vi.fn>
        expect(writeFile).toHaveBeenCalledWith(`${REPO}/myAutomation.h`, configFiles[1].content)
    })

    it('writes all config files', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles } })
        await ws.compile()
        const writeFile = (ws as any).files.writeFile as ReturnType<typeof vi.fn>
        expect(writeFile).toHaveBeenCalledTimes(configFiles.length)
    })

    it('saveFiles is called before cli.compile', async () => {
        const callOrder: string[] = []
        const files = {
            writeFile: vi.fn().mockImplementation(async () => { callOrder.push('writeFile') }),
        } as unknown as FileService
        const cli = {
            compile: vi.fn().mockImplementation(async () => { callOrder.push('compile'); return { success: true, output: '' } }),
        } as unknown as ArduinoCliService
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles }, cli, files })
        await ws.compile()
        expect(callOrder[0]).toBe('writeFile')
        expect(callOrder[callOrder.length - 1]).toBe('compile')
    })

    it('config.h content contains IP_PORT 2560 (regression: was missing, caused compile error)', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles } })
        await ws.compile()
        const writeFile = (ws as any).files.writeFile as ReturnType<typeof vi.fn>
        const configHWrite = writeFile.mock.calls.find((c: string[]) => c[0].endsWith('config.h'))
        expect(configHWrite![1]).toContain('#define IP_PORT 2560')
    })

    it('config.h content contains WIFI_HOSTNAME when WiFi enabled (regression: was missing, caused compile error)', async () => {
        const wifiConfigFiles = [
            {
                name: 'config.h',
                content: '#define IP_PORT 2560\n#define SCROLLMODE 1\n#define WIFI_HOSTNAME "dccex"\n#define ENABLE_WIFI true\n',
            },
        ]
        const ws = makeWorkspace({ state: { selectedDevice: espDevice, repoPath: REPO, configFiles: wifiConfigFiles } })
        await ws.compile()
        const writeFile = (ws as any).files.writeFile as ReturnType<typeof vi.fn>
        const configHWrite = writeFile.mock.calls.find((c: string[]) => c[0].endsWith('config.h'))
        expect(configHWrite![1]).toContain('#define WIFI_HOSTNAME "dccex"')
    })
})

// ── cli.compile invocation ────────────────────────────────────────────────────

describe('Workspace.compile — cli.compile invocation', () => {
    it('calls cli.compile with the correct repoPath', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect((ws as any).cli.compile).toHaveBeenCalledWith(REPO, megaDevice.fqbn)
    })

    it('calls cli.compile with the correct fqbn for Mega', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect((ws as any).cli.compile).toHaveBeenCalledWith(expect.any(String), 'arduino:avr:mega')
    })

    it('calls cli.compile with the correct fqbn for ESP32-S3', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: espDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect((ws as any).cli.compile).toHaveBeenCalledWith(expect.any(String), 'esp32:esp32:esp32s3')
    })

    it('calls cli.compile exactly once per compile() call', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect((ws as any).cli.compile).toHaveBeenCalledTimes(1)
    })

    it('calls cli.compile twice when compile() is called twice', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        await ws.compile()
        expect((ws as any).cli.compile).toHaveBeenCalledTimes(2)
    })
})

// ── Progress sequence ─────────────────────────────────────────────────────────

describe('Workspace.compile — progress tracking', () => {
    it('reaches progressPercent 70 on success', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect(ws.progressPercent).toBe(70)
    })

    it('progressPercent stays below 70 on failure (does not advance past compile step)', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '', error: 'err' }) },
        })
        await ws.compile()
        expect(ws.progressPercent).toBeLessThan(70)
    })
})

// ── Log output ────────────────────────────────────────────────────────────────

describe('Workspace.compile — log output', () => {
    it('log contains "Compiling for {fqbn}..."', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect(ws.compileLog).toContain('Compiling for arduino:avr:mega')
    })

    it('log contains compiler stdout output', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: true, output: 'Sketch uses 12345 bytes (47%)' }) },
        })
        await ws.compile()
        expect(ws.compileLog).toContain('Sketch uses 12345 bytes (47%)')
    })

    it('log contains compiler stdout even on failure', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: {
                compile: vi.fn().mockResolvedValue({
                    success: false,
                    output: "DCCTimerESP.cpp:102:8: error: 'sens_dev_t' has no member named 'sar_meas_start1'",
                    error: 'Compilation failed',
                }),
            },
        })
        await ws.compile()
        expect(ws.compileLog).toContain("'sar_meas_start1'")
    })

    it('log contains success marker on success', async () => {
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] } })
        await ws.compile()
        expect(ws.compileLog).toContain('✓ Compile successful!')
    })

    it('log does not contain success marker on failure', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '', error: 'failed' }) },
        })
        await ws.compile()
        expect(ws.compileLog).not.toContain('✓ Compile successful!')
    })
})

// ── Success outcome ───────────────────────────────────────────────────────────

describe('Workspace.compile — success outcome', () => {
    let ws: Workspace

    beforeEach(async () => {
        ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles },
            cli: { compile: vi.fn().mockResolvedValue({ success: true, output: 'Sketch uses 12345 bytes' }) },
        })
        await ws.compile()
    })

    it('sets compileSuccess=true', () => {
        expect(ws.compileSuccess).toBe(true)
    })

    it('compileError remains null', () => {
        expect(ws.compileError).toBeNull()
    })

    it('isCompiling is false when done', () => {
        expect(ws.isCompiling).toBe(false)
    })

    it('progressPercent is 70', () => {
        expect(ws.progressPercent).toBe(70)
    })
})

// ── Failure outcomes ──────────────────────────────────────────────────────────

describe('Workspace.compile — failure outcomes', () => {
    it('sets compileSuccess=false on failure', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '', error: 'bad' }) },
        })
        await ws.compile()
        expect(ws.compileSuccess).toBe(false)
    })

    it('surfaces the compiler error string', async () => {
        const errMsg = "error: 'WIFI_HOSTNAME' was not declared in this scope"
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '', error: errMsg }) },
        })
        await ws.compile()
        expect(ws.compileError).toBe(errMsg)
    })

    it("falls back to 'Compilation failed' when no error string is provided", async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '' }) },
        })
        await ws.compile()
        expect(ws.compileError).toBe('Compilation failed')
    })

    it('isCompiling is false after failure', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockResolvedValue({ success: false, output: '', error: 'err' }) },
        })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
    })

    it('isCompiling is false even when cli.compile throws unexpectedly', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockRejectedValue(new Error('IPC channel closed')) },
        })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
        expect(ws.compileSuccess).toBe(false)
    })

    it('captures unexpected thrown error message', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] },
            cli: { compile: vi.fn().mockRejectedValue(new Error('IPC channel closed')) },
        })
        await ws.compile()
        expect(ws.compileError).toBe('IPC channel closed')
    })

    it('isCompiling is false when writeFile throws', async () => {
        const ws = makeWorkspace({
            state: { selectedDevice: megaDevice, repoPath: REPO, configFiles },
            files: { writeFile: vi.fn().mockRejectedValue(new Error('EACCES: permission denied')) },
        })
        await ws.compile()
        expect(ws.isCompiling).toBe(false)
        expect(ws.compileSuccess).toBe(false)
    })
})

// ── Idempotency: successive calls ─────────────────────────────────────────────

describe('Workspace.compile — successive calls', () => {
    it('second call overwrites first failure with success', async () => {
        const compileMock = vi.fn()
            .mockResolvedValueOnce({ success: false, output: '', error: 'first run error' })
            .mockResolvedValueOnce({ success: true, output: 'OK' })
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] }, cli: { compile: compileMock } })
        await ws.compile()
        expect(ws.compileSuccess).toBe(false)
        await ws.compile()
        expect(ws.compileSuccess).toBe(true)
        expect(ws.compileError).toBeNull()
    })

    it('second call clears log from first run', async () => {
        const compileMock = vi.fn()
            .mockResolvedValueOnce({ success: true, output: 'first run output' })
            .mockResolvedValueOnce({ success: true, output: 'second run output' })
        const ws = makeWorkspace({ state: { selectedDevice: megaDevice, repoPath: REPO, configFiles: [] }, cli: { compile: compileMock } })
        await ws.compile()
        await ws.compile()
        expect(ws.compileLog).not.toContain('first run output')
        expect(ws.compileLog).toContain('second run output')
    })
})
